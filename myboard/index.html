<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>🔥 게시판</title>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR&display=swap" rel="stylesheet">
  <style>
    body { font-family: 'Noto Sans KR', sans-serif; background: #1e1e1e; color: #e5e7eb; max-width: 800px; margin: auto; padding: 20px; }
    .topbar { display: flex; justify-content: flex-end; align-items: center; gap: 10px; margin-bottom: 10px; }
    .card { background: #2d2d2d; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: 0 4px 14px rgba(0,0,0,0.2); }
    input, textarea { width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #555; border-radius: 8px; background: #1e1e1e; color: #e5e7eb; }
    button { background: #4f46e5; color: white; padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; }
    button:hover { background: #6366f1; }
    .post-item { padding: 4px 0; border-bottom: 1px solid #444; }
    .post-item .title {
  margin: 0;             /* 불필요한 여백 제거 */
  padding: 0;            /* 타이틀 자체 패딩 없애기 */
  line-height: 1;        /* 폰트 크기와 동일한 높이 */
  font-size: 1rem;       /* 필요하면 폰트 크기도 소폭 줄이기 */
  height: 1rem;          /* 정확히 한 줄 높이 */
  overflow: hidden;      /* 혹시 넘칠 때 숨기기 */
  white-space: nowrap;   /* 줄 바꿈 없이 한 줄로 */
  text-overflow: ellipsis;
}
    .post-item .comment-count { font-size: 0.6em; margin-left: 6px; background: #444; padding: 1px 4px; border-radius: 12px; }
 
/* 헤더: 제목·메타·조회수 배치 */
.post-item .header {
  display: flex;
  justify-content: space-between; /* 좌우 끝으로 배치 */
  align-items: center;
}

/* 작성자/날짜 세로 스택, 우측 정렬 */
.post-item .meta-container {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  font-size: 0.5em;    /* 메타 글씨는 50% 크기 */
  line-height: 1.2;
}

/* 조회수는 메타 옆, 같은 행에 */
.post-item .views {
  margin-left: 16px;   /* 메타와 간격 */
  white-space: nowrap;
  font-size: 0.5em;    /* 조회수 글씨도 50% */
}

    /* 제목은 남은 공간을 채우기 */
.post-item .title {
  flex: 1;
  margin-right: 12px;  /* 메타와 겹치지 않게 */
}

/* 메타 정보(작성자/날짜 등) 높이도 줄이려면 */
.post-item .meta span {
  line-height: 1;        /* 기본 보다 좁게 */
  margin: 0;             /* 간격 없애기 */
  padding: 0;
  font-size: 0.7em;
}

    .centered { display: flex; justify-content: center; margin-top: 10px; }
    .uploading { text-align: center; color: #facc15; margin-bottom: 10px; }
    .pagination button.active { background: #6366f1; cursor: default; opacity: 0.8; }
    img.uploaded-img, video, iframe { width: 100%; margin-top: 10px; }
    .post-actions { display: flex; justify-content: center; gap: 10px; margin-top: 10px; }
          .comment-section {
        display: flex;
        flex-direction: column;  /* 입력창, 버튼, 댓글목록을 세로로 쌓습니다 */
        align-items: center;     /* 자식 요소들을 수평 중앙 정렬합니다 */
        margin-top: 10px;
      }

      /* 버튼만 위쪽 여백을 주고 중앙에 고정 */
      .comment-section button {
        margin-top: 8px;
      }

      /* 댓글 목록은 너비만 채워주면 됩니다 */
      .comment-section ul {
        width: 100%;
      }
    .comment-item { display: flex; justify-content: space-between; padding: 4px 0; }

        /* 글 내용 줄바꿈 보존 */
    div[id^="post-content-"] {
      white-space: pre-wrap;
    }
  </style>
  <link rel="icon" href="favicon.ico" />
</head>
<body>
  <div class="topbar">
    <p id="user">로그인 상태 확인 중...</p>
    <button id="login">로그인</button>
    <button id="logout" style="display:none">로그아웃</button>
  </div>
  <h1>🔥 Firebase_Board 🔥</h1> 
  <div id="postList"></div>
  <div id="pagination" class="pagination"></div>
  <form id="postForm" style="display:none" class="card">
    <input name="title" placeholder="제목 입력" required>
    <textarea name="content" rows="4" placeholder="내용 입력" required></textarea>
    <input type="file" name="files" multiple>
    <div class="uploading" id="uploadStatus" style="display:none;">업로드 중입니다...</div>
    <div class="centered"><button type="submit">글 작성</button></div>
  </form>

  <script type="module">

    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-app.js";
    import { getFirestore, collection, addDoc, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, serverTimestamp, orderBy, query, limit, startAfter, increment, getCountFromServer } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-firestore.js";
    import { getAuth, onAuthStateChanged, signInWithPopup, GoogleAuthProvider, signOut } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-auth.js";
    import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.9.0/firebase-storage.js";
  // ② 모듈 코드 – 여기부터 자유롭게 변수/함수 선언
  let lastOpenedDetail = null;
  const pageCursors = {};


    const firebaseConfig = {
      apiKey: "AIzaSyC6RvL8x2EQrgy8aSc8R63fzRvg85fX32w",
      authDomain: "my-board-project-58b71.firebaseapp.com",
      projectId: "my-board-project-58b71",
      storageBucket: "my-board-project-58b71.firebasestorage.app",
      messagingSenderId: "720342019721",
      appId: "1:720342019721:web:910184dbb03e4451b1e058"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const storage = getStorage(app);

    let currentUser = null;
    const perPage = 12; // 페이지당 게시물 수

    document.getElementById('login').onclick  = () => signInWithPopup(auth, new GoogleAuthProvider());
    document.getElementById('logout').onclick = () => signOut(auth);
    onAuthStateChanged(auth, user => {
      currentUser = user;
      document.getElementById('user').textContent = user ? `👤 ${user.displayName}` : '로그인 필요';
      document.getElementById('login').style.display  = user ? 'none' : 'inline-block';
      document.getElementById('logout').style.display = user ? 'inline-block' : 'none';
      document.getElementById('postForm').style.display = user ? 'block' : 'none';
        // ← 여기서만 초기 로드
       loadPosts(1);
      
    });

    // 글 작성
    document.getElementById('postForm').onsubmit = async e => {
      e.preventDefault();
      document.getElementById('uploadStatus').style.display = 'block';
      try {
        const title = e.target.title.value;
        const content = e.target.content.value;
        const files = e.target.files.files;
        const attachments = [];
        for (const f of files) {
          const r = ref(storage, `uploads/${Date.now()}-${f.name}`);
          const s = await uploadBytes(r, f);
          attachments.push({ name: f.name, url: await getDownloadURL(s.ref) });
        }
        // photoURL 포함
        await addDoc(collection(db, 'posts'), {
          title, content,
          uid: currentUser.uid,
          username: currentUser.displayName,
          photoURL: currentUser.photoURL,
          attachments,
          likes: 0,
          views: 0,
          commentCount: 0,
          createdAt: serverTimestamp()
        });
        e.target.reset();
        loadPosts(1);
      } catch (err) {
        console.error(err);
        alert('오류 발생');
      } finally {
        document.getElementById('uploadStatus').style.display = 'none';
      }
    };

    async function getTotalPosts() {
      const countSnap = await getCountFromServer(collection(db, 'posts'));
      return countSnap.data().count;
}

function renderPagination(currentPage, totalPosts) {
  const totalPages  = Math.ceil(totalPosts / perPage);
  const windowSize  = 4;
  const windowStart = Math.floor((currentPage - 1) / windowSize) * windowSize + 1;
  const windowEnd   = Math.min(windowStart + windowSize - 1, totalPages);

  const pg = document.getElementById('pagination');
  pg.innerHTML = '';

  // ◀ 이전 블럭
  if (windowStart > 1) {
    const b = document.createElement('button');
    b.textContent = '<';
    b.onclick = () => loadPosts(windowStart - 1);
    pg.appendChild(b);
  }

  // 숫자 버튼
  for (let i = windowStart; i <= windowEnd; i++) {
    const b = document.createElement('button');
    b.textContent = i;
    if (i === currentPage) b.classList.add('active');
    b.onclick = () => loadPosts(i);
    pg.appendChild(b);
  }

  // ▶ 다음 블럭
  if (windowEnd < totalPages) {
    const next = document.createElement('button');
    next.textContent = '>';
    next.onclick = () => loadPosts(windowEnd + 1);
    pg.appendChild(next);
  }
}

    // 게시글 리스트 (페이지네이션)
    async function loadPosts(page = 1) {
  const list = document.getElementById('postList');
  list.innerHTML = '';

  let snap;
  if (page === 1) {
    // 첫 페이지: 단순 limit
    snap = await getDocs(query(
      collection(db, 'posts'),
      orderBy('createdAt', 'desc'),
      limit(perPage)
    ));
  }  else {
    // 이전 페이지 cursor
    const cursor = pageCursors[page - 1];
    console.log(`Loading page ${page}, using cursor:`, cursor);
    if (!cursor) {
      // 이전 페이지 한 번 채워줘야 다음 커서가 설정됩니다.
      await loadPosts(page - 1);
    }
    const lastDoc = pageCursors[page - 1];
    snap = await getDocs(query(
      collection(db, 'posts'),
      orderBy('createdAt', 'desc'),
      startAfter(lastDoc),
      limit(perPage)
    ));
  }

  // 이 페이지의 마지막 문서를 커서로 저장
  if (snap.docs.length) {
    pageCursors[page] = snap.docs[snap.docs.length - 1];
  }

  // 렌더링
  for (const d of snap.docs) {
    const p = d.data();
    const comSnap = await getDocs(collection(db, 'posts', d.id, 'comments'));
    const commentCount = comSnap.size;
    const dateStr = p.createdAt?.toDate().toLocaleString();
    const div = document.createElement('div');
    div.className = 'post-item';
    div.onclick = () => toggleDetail(div, d.id);
     div.innerHTML = `
   <div class="header">
     <div class="title">${p.title}<span class="comment-count">${commentCount}</span></div>
     <div class="meta">
       <span class="author">${p.username}</span>
       <span class="post-date">${dateStr}</span>
       <span class="views">${p.views}</span>
     </div>
   </div>
   <div class="detail" style="display:none"></div>
 `;
    list.appendChild(div);
  }

  // 전체 개수 집계로 페이징 버튼
  const totalPosts = await getCountFromServer(collection(db, 'posts')).then(s => s.data().count);
  renderPagination(page, totalPosts);
}

// 게시글 상세 하단 댓글 불러오기
async function loadComments(postId) {
    const listEl = document.getElementById(`comment-list-${postId}`);
    if (!listEl) return;
    listEl.innerHTML = '';

    // 댓글 컬렉션에서 createdAt 순 정렬 후 불러오기
    const q = query(
      collection(db, 'posts', postId, 'comments'),
      orderBy('createdAt')
    );
    const snapshot = await getDocs(q);
    snapshot.forEach(docC => {
      const data = docC.data();
      const li = document.createElement('li');
      li.className = 'comment-item';
      li.innerHTML = `<span>${data.author}: ${data.text}</span>`;
      listEl.appendChild(li);
    });
  }
  // inline onclick 등에서 참조할 수 있도록 전역에 노출
  window.loadComments = loadComments;


    // 상세 보기
     async function toggleDetail(wrapper, id) {
   const detail = wrapper.querySelector('.detail');
   // ① 이전 상세창이 있으면 닫아준다
   if (lastOpenedDetail && lastOpenedDetail !== detail) {
     lastOpenedDetail.style.display = 'none';
   }
      if (detail.style.display === 'block') {
        detail.style.display = 'none';
        return;
      }
      const refDoc = doc(db, 'posts', id);
      const [snap] = await Promise.all([
        getDoc(refDoc),
        updateDoc(refDoc, { views: increment(1) })
      ]);
      const p = snap.data();
      const dateStr = p.createdAt?.toDate().toLocaleString();
      const embedded = [];
      const contentHtml = p.content.replace(
        /https:\/\/(www\.)?youtube\.com\/watch\?v=([\w-]+)/g,
        (m, _, vid) => {
          embedded.push(`<iframe loading="lazy" src="https://www.youtube.com/embed/${vid}" frameborder="0" allowfullscreen></iframe>`);
          return m;
        }
      );
      const filesHtml = (p.attachments || [])
        .map(f => f.name.match(/\.(jpe?g|png|gif)$/i)
          ? `<img src="${f.url}" class="uploaded-img" loading="lazy">`
          : `<video src="${f.url}" controls loading="lazy"></video>`
        ).join('');
      const isOwner = currentUser && (currentUser.uid === p.uid);

      detail.innerHTML = `
        <div class="card" onclick="event.stopPropagation()">
          <h3 id="post-title-${id}">${p.title}</h3>
          <div id="post-content-${id}">${p.content}</div>
          ${embedded.join('')}
          ${filesHtml}
          <div class="post-actions">
            ${isOwner ? `<button onclick="event.stopPropagation(); editPost('${id}')">✏️ 수정</button>
                          <button onclick="event.stopPropagation(); deletePost('${id}')">🗑️ 삭제</button>` : ''}
            <button onclick="event.stopPropagation(); likePost('${id}')">👍 (<span id="like-count-${id}">${p.likes ?? 0}</span>)</button>
          </div>
          <div class="comment-section">
            <input id="comment-input-${id}" type="text" placeholder="댓글 달기">
            <button onclick="event.stopPropagation(); addComment('${id}')">댓글 작성</button>
            <ul id="comment-list-${id}"></ul>
          </div>
        </div>`;
      detail.style.display = 'block';
      loadComments(id);
         // ② 지금 연 상세창을 저장해 둔다
        lastOpenedDetail = detail;
    }

// 수정 기능 (제목+내용)
async function editPost(id) {
  const titleEl   = document.getElementById(`post-title-${id}`);
  const contentEl = document.getElementById(`post-content-${id}`);

  // 1) 기존 콘텐츠 숨기기
  titleEl.style.display   = 'none';
  contentEl.style.display = 'none';

  // 2) 편집용 폼 컨테이너 생성
  const editDiv = document.createElement('div');
  editDiv.innerHTML = `
    <input id="edit-title-${id}" type="text" value="${titleEl.textContent}" style="width:100%;margin-bottom:6px;padding:4px;" />
    <textarea id="edit-content-${id}" rows="6" style="width:100%;padding:4px;">${contentEl.textContent}</textarea>
    <div style="text-align:right;margin-top:6px;">
      <button id="save-btn-${id}">저장</button>
      <button id="cancel-btn-${id}">취소</button>
    </div>
  `;
  // insert after contentEl
  contentEl.parentNode.insertBefore(editDiv, contentEl.nextSibling);

  // 3) 취소 버튼 핸들러
  document.getElementById(`cancel-btn-${id}`).onclick = () => {
    editDiv.remove();
    titleEl.style.display   = '';
    contentEl.style.display = '';
  };

  // 4) 저장 버튼 핸들러
  document.getElementById(`save-btn-${id}`).onclick = async () => {
    const newTitle   = document.getElementById(`edit-title-${id}`).value;
    const newContent = document.getElementById(`edit-content-${id}`).value;
    // Firestore 업데이트
    await updateDoc(doc(db,'posts',id), {
      title:   newTitle,
      content: newContent
    });
    // 화면 반영 및 정리
    titleEl.textContent   = newTitle;
    contentEl.textContent = newContent;
    editDiv.remove();
    titleEl.style.display   = '';
    contentEl.style.display = '';
  };
}

// 좋아요 1회 제한
async function likePost(id) {
  if (!currentUser) { alert('로그인 후 이용해주세요.'); return; }
  const likeRef = doc(db, 'posts', id, 'likes', currentUser.uid);
  const likeSnap = await getDoc(likeRef);
  if (likeSnap.exists()) { alert('이미 좋아요를 누르셨습니다.'); return; }
  await setDoc(likeRef, { uid: currentUser.uid, createdAt: serverTimestamp() });
  await updateDoc(doc(db, 'posts', id), { likes: increment(1) });
  const e = document.getElementById(`like-count-${id}`);
  if (e) e.textContent = parseInt(e.textContent||'0')+1;
}

// 댓글 쓰기
async function addComment(id) {
  const i = document.getElementById(`comment-input-${id}`);
  if (!i.value.trim()) return;
  await addDoc(collection(db,'posts',id,'comments'), {
    text: i.value,
    author: currentUser.displayName,
    uid: currentUser.uid,
    createdAt: serverTimestamp()
  });
  i.value = '';
  loadComments(id);
}

// 댓글 삭제
async function deleteComment(pid, cid) {
  if (!confirm('댓글 삭제?')) return;
  await deleteDoc(doc(db,'posts',pid,'comments',cid));
  loadComments(pid);
}

// 글 삭제
async function deletePost(id) {
  if (!confirm('삭제하시겠습니까?')) return;
  await deleteDoc(doc(db,'posts',id));
  loadPosts(1);
}

// 전역 노출
window.editPost      = editPost;
window.likePost      = likePost;
window.addComment    = addComment;
window.deleteComment = deleteComment;
window.deletePost    = deletePost;

    
  </script>
</body>
</html>
